**操作系统**

linux 命令查看cpu核数 内存情况
linux进程间通信的方式：
1.管道（有名 无名） 2.信号量 3.共享内存


![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16156543558297.jpg)

关于操作系统和他的内核：

![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16156548141355.jpg)


![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16156549630693.jpg)

fork vfork clone的区别：
fork后会将子进程放在队列前面，防止因为太多可以避免的写时复制而导致效率的下降。
vfork共享父进程空间
clone创建线程，可以有选择的继承父进程内存

命名空间名和作用域分辨符：
nsl::a，nsl::b

孤儿进程 僵尸进程 及其危害？

![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16156944044537.jpg)

linux的解压命令（常用的）：

![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16156972652857.jpg)

cpu大端和小端存储？
大端：数据高字节保存在内存低地址，数据低字节保存在内存的高地址中，地址由小向大增加，而数据从高位往低位放。
小端：高字节保存在高地址，低字节保存在低地址。

![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16156984841683.jpg)



**进程和线程的区别？**

-CyC2018

进程三种状态：
1.就绪 2.阻塞 3.执行

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JCakFGRjRoY3dvZmFTWkNGZVdadzlIN1M1Y3F0bjR3OEtYQXpTcVV2R3BTRFp3THBndlE0bGlhMENDSU1lQzVCSXBNcFE3dnJHWXAyVmZxdkw2Q05ldy82NDA?x-oss-process=image/format,png)



**进程和线程切换有什么步骤,开销怎么样**

https://blog.csdn.net/L13763338360/article/details/104961469/





讲一讲进程控制块：
操作系统通过进程控制块来对进程进行控制和管理。PCB通常在系统内存中占用一块连续的分区，存放着os用于描述、控制进程情况的全部信息。

为什么需要CPU调度？
CPU调度的目标是在任何时候都有某些进程在运行，是CPU使用率最大化。  同一时刻 只有一个进程占有CPU资源，但一个进程在等待IO时等等一些阻塞进程的动作时，CPU就回空闲出来，这时候，我们应该让这个阻塞的进程让出CPU资源，让其他已经处于就绪状态的进程执行。这样就可以使CPU使用率最大化。

什么是死锁？
在多道程序环境下，多个进程可能竞争一定数量的资源，某个进程申请资源，如果这时这个资源不可用，那么这个进程就进入等待状态。如果所申请的资源被其他等待进程占有，那么该等待进程可能再也无法改变其状态，一直等待下去，这种情况称之为 死锁。

死锁的四个条件：
1.互斥 2.不可抢占 3.占有且申请 4.循环等待

cache的作用？
cache是处于 CPU寄存器 和 内存之间的一层缓存，用来加快CPU的取指速率， 使用时： CPU需要数据时，首先会查找cache中有没有需要的数据，如果有，则取走，如果没有，则查询内存，并将数据更新到缓存中，以供下次取指。

*内存的段页式管理的优缺点？*
1.段式存储管理（逻辑地址）
将程序的地址空间划分为若干个段，每个进程都有一个二维（段名 段内地址）的地址空间，程序通过分段来划分为多个模块。
优点：没有内碎片。


2.页式存储管理（一维）（物理地址）
程序的逻辑地址划分为固定大小的页，物理内存则为页框。
优点：没有外碎片，一个程序不必连续存放。便于更改内存占用的空间大小。

页是信息的物理单位，段是信息的逻辑单位。页大小由系统决定，段大小决定于用户编写的程序。

3.段页式存储管理
地址结构：段号，段内页号，页内地址
缺点：开销变大，执行速度下降

内碎片（已分配） 外碎片（未分配）

内存：
1.虚拟内存
经常被分割成多个物理内存碎片，还有部分占时存储在外部磁盘存储器上面

2.物理内存
物理地址被分成离散的单元，称为页

信号量：
sem_wait 减少空位
Sem_post 增加空位

线程同步的方式：
1.互斥量
2.信号量



![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16157151183692.jpg)

就绪状态：进程缺少cpu 等待状态：进程需要其他资源（除了cpu）或等待某一事件。

用户态
核心态

段式存储管理和页式存储管理：

![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16157157199137.jpg)

操作系统进程调度的策略：

![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16157158537922.jpg)

**本地的进程间通信**
本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：

1、消息传递（管道、命名管道FIFO、消息队列）
2、同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）
3、共享内存（匿名的和具名的）：是最快的IPC方式。通常配合其他通信机制比如信号量，来实现进程同步的通信。
4、远程过程调用（Solaris门和Sun RPC）

**同步操作和异步操作**

同步指的是一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。



异步指的是每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。



**进程间同步**

1.信号量和PV操作

2.条件临界区

3.管程

（同步和通信联系紧密）

**进程内（线程间）同步**

![image-20210319182749356](file://C:\Users\FuNgaiKa\AppData\Roaming\Typora\typora-user-images\image-20210319182749356.png?lastModify=1616166873)

互斥量、读写锁、信号量、临界区、条件变量

**进程互斥**

临界区、peterson算法、lamport算法



**IO多路复用的三种机制Select，Poll，Epoll的区别**

