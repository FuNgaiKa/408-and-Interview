**操作系统**

linux 命令查看cpu核数 内存情况
linux进程间通信的方式：
1.管道（有名 无名） 2.信号量 3.共享内存


![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16156543558297.jpg)

**关于操作系统和他的内核：**



**fork vfork clone的区别：**
1.fork后会将子进程放在队列前面，防止因为太多可以避免的写时复制而导致效率的下降。（执行顺序不可知，依赖于不同系统对fork的实现；多核机器上父子进程同时执行）
2.vfork保证子进程先执行，共享父进程的地址空间和页表项。

只完成了一件事：复制内部的内核数据结构。



3.lone创建线程，可以有选择的继承父进程内存



命名空间名和作用域分辨符：
nsl::a，nsl::b

孤儿进程 僵尸进程 及其危害？

![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16156944044537.jpg)

linux的解压命令（常用的）：

![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16156972652857.jpg)

cpu大端和小端存储？
大端：数据高字节保存在内存低地址，数据低字节保存在内存的高地址中，地址由小向大增加，而数据从高位往低位放。
小端：高字节保存在高地址，低字节保存在低地址。

![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16156984841683.jpg)



**进程和线程的区别？**

-CyC2018

1.一个进程崩溃不会对其他进程造成影响；线程死掉会影响其他线程。

2.进程是CPU资源分配的基本单位，线程是CPU调度的基本单位。

3.进程开销:进程创建和撤销的时候开销大；线程开销小。

4.通信:线程间的通信方便；进程稍微复杂

5.进程编程调试简单；线程调试较复杂。

**多进程和多线程的使用场景**

多进程适合CPU密集型，多线程适合I/O密集型，单机多核分布式场景。

（公司很多个房子的例子）

![preview](https://pic3.zhimg.com/v2-add56b22280bb4d4ba61b27fdc4d8bc2_r.jpg)

**场景1--IO密集型应用：**

高速的CPU会停下来等待低速的外设，比如磁盘或网卡。如果不用多线程，基本上99%的CPU时间在等待。

如果等待期间，又去接受其它的用户请求，比如另一个http连接，多少可以利用一点闲置的CPU资源；



**场景2--CPU密集型应用：**

高速的CPU(内核)等待低速的总线，比如存取内存变量。与场景1同理。



其实多进程也能解决问题，但是性能开销、编码便利性(适用面)各有不同，这又是另一个话题了。



**使用多线程要注意什么呢？**

**线程和进程上下文切换？**

开销:进程>线程。

线程如何减少开销：

1.减少不必要的线程创建

2.协程。





进程三种状态：
1.就绪 2.阻塞 3.执行

运行到就绪：时间片到、高优先级。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JCakFGRjRoY3dvZmFTWkNGZVdadzlIN1M1Y3F0bjR3OEtYQXpTcVV2R3BTRFp3THBndlE0bGlhMENDSU1lQzVCSXBNcFE3dnJHWXAyVmZxdkw2Q05ldy82NDA?x-oss-process=image/format,png)



**进程和线程切换有什么步骤,开销怎么样**

https://blog.csdn.net/L13763338360/article/details/104961469/

**有了进程为什么要有线程？**

-牛客面试宝典（1）

进程同一时间只能干一件事；挂起；

线程优势：1.资源 2.切换效率 3.通信方式

（线程间通信容易一些）



**线程间通信（同步）**





**协程**

https://blog.csdn.net/qq_25424545/article/details/81529717

https://blog.csdn.net/u014630623/article/details/88914176

https://zhuanlan.zhihu.com/p/172471249

（自己得总结一下）：

类比多线程中的 线程切换 。但是不需要多线程的锁机制。

协程刚好可以解决上述2个问题。协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。**协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程**，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。

在有大量IO操作业务的情况下，我们采用协程替换线程，可以到达很好的效果，一是降低了系统内存（次要），二是减少了系统切换开销，因此系统的性能也会提升。

注意：

线程不需要这么多 -> 用线程池。

协程只是减少线程切换 -> 所以速度快。



**讲讲交换技术**

I/O速度比处理机速度慢得多。为了防止所有进程阻塞等待I/O，将一部分进程换到外存，腾出内存空间（进程状态变成挂起）。

活动阻塞、静止阻塞。

活动就绪、静止就绪。



**讲一讲进程控制块：**
操作系统通过进程控制块来对进程进行控制和管理。PCB通常在系统内存中占用一块连续的分区，存放着os用于描述、控制进程情况的全部信息。

为什么需要CPU调度？
CPU调度的目标是在任何时候都有某些进程在运行，是CPU使用率最大化。  同一时刻 只有一个进程占有CPU资源，但一个进程在等待IO时等等一些阻塞进程的动作时，CPU就回空闲出来，这时候，我们应该让这个阻塞的进程让出CPU资源，让其他已经处于就绪状态的进程执行。这样就可以使CPU使用率最大化。

**什么是死锁？**

在多道程序环境下，多个进程可能竞争一定数量的资源，某个进程申请资源，如果这时这个资源不可用，那么这个进程就进入等待状态。如果所申请的资源被其他等待进程占有，那么该等待进程可能再也无法改变其状态，一直等待下去，这种情况称之为 死锁。

**死锁的四个条件：**
1.互斥 2.不可抢占 3.占有且申请（不可剥夺，只能在使用后自己释放） 4.循环等待

cache的作用？
cache是处于 CPU寄存器 和 内存之间的一层缓存，用来加快CPU的取指速率， 使用时： CPU需要数据时，首先会查找cache中有没有需要的数据，如果有，则取走，如果没有，则查询内存，并将数据更新到缓存中，以供下次取指。

*内存的段页式管理的优缺点？*
1.段式存储管理（逻辑地址）
将程序的地址空间划分为若干个段，每个进程都有一个二维（段名 段内地址）的地址空间，程序通过分段来划分为多个模块。
优点：没有内碎片。

2.页式存储管理（一维）（物理地址）
程序的逻辑地址划分为固定大小的页，物理内存则为页框。
优点：没有外碎片，一个程序不必连续存放。便于更改内存占用的空间大小。

页是信息的物理单位，段是信息的逻辑单位。页大小由系统决定，段大小决定于用户编写的程序。

3.段页式存储管理
地址结构：段号，段内页号，页内地址
缺点：开销变大，执行速度下降

内碎片（已分配） 外碎片（未分配）

内存：
1.虚拟内存
经常被分割成多个物理内存碎片，还有部分占时存储在外部磁盘存储器上面

2.物理内存
物理地址被分成离散的单元，称为页

信号量：
sem_wait 减少空位
Sem_post 增加空位





![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16157151183692.jpg)

就绪状态：进程缺少cpu 等待状态：进程需要其他资源（除了cpu）或等待某一事件。

用户态
核心态

段式存储管理和页式存储管理：

![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16157157199137.jpg)

操作系统进程调度的策略：

![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16157158537922.jpg)



**线程同步（通信）方式：**
1.互斥量
2.信号量

3.临界区

4.事件（信号）



**进程间通信**
本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：

1.管道

2.系统IPC：消息队列，

信号量（实际上是一个计数器，用于实现进程间的互斥和同步，而不是用于存储进程间通信数据），

共享内存（最快的IPC，因为进程是对内存的直接读取，经常和信号量一起使用，来完成同步和通信）

3.套接字socket（用于不同主机之间的进程通信）





**同步操作和异步操作**

同步指的是一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。



异步指的是每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。



**进程间同步**

1.信号量和PV操作

2.条件临界区

3.管程

（同步和通信联系紧密）

**进程内（线程间）同步**

![image-20210319182749356](file://C:\Users\FuNgaiKa\AppData\Roaming\Typora\typora-user-images\image-20210319182749356.png?lastModify=1616166873)

互斥量、读写锁、信号量、临界区、条件变量

**进程互斥**

临界区、peterson算法、lamport算法

**进程间通信和线程间通信**

https://blog.csdn.net/feelinghappy/article/details/108087038



**IO多路复用的三种机制Select，Poll，Epoll的区别**



**Linux文件系统**

https://zhuanlan.zhihu.com/p/128669031



**Linux的一些指令**

解压命令       unzip 文件名.zip  /  tar -xvf 文件名.tar.gz
查看连接状态  netstat
查看运行中的进程  ps
杀死运行中的进程   kill  pid
查看内存  free
查看CPU占用  top
查看端口  netstat  -anp | grep 端口号

https://www.runoob.com/w3cnote/linux-common-command-2.html







**关于文件**

https://liuyehcf.github.io/2017/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F1/

文件的典型存储介质：磁盘。

访问磁盘的时间主要是寻道时间。

寻道时间：***\*磁头\****从开始移动到数据所在**磁道**所需要的时间。寻道时间越短，I/O操作越快。（磁道，扇区，柱面）



![image](http://static.oschina.net/uploads/img/201312/24091906_1mMg.png)



磁盘调度算法：

1.先来先服务FCFS

2.最短寻道时间优先SSTF

3.电梯算法SCAN



**局部性原理**

1.时间局限性

2.空间局限性



（虚拟）**内存调度**

关于调换页面置换的算法。

1.最佳置换

2.先进先出

3.最近最久未使用（LRU）



**linux的shell脚本删除一个月前的日志**

1.根据文件修改日期

2.根据文件名

3.定期执行脚本



**互斥锁（mutex）和读写锁的机制、区别？**

互斥锁：只有一个线程访问，其他睡眠

读写锁：写者优先；多线程读，一线程写；写的时候不可以读。

自旋锁：区别互斥锁的睡眠——原地自旋直到锁被释放。

条件变量。(通常和互斥锁一起使用)（类似轮询）

**说说你用到过的锁**

生产者消费者问题：互斥锁、条件变量。



**区分内存泄漏和内存溢出**

都可以因为内存未能及时回收而产生。



**系统调用**

管态：核心态

目态：用户态

访问系统核心功能，或者危险的、权限高的指令，通过接口使用系统调用。

**请介绍一下操作系统的中断**

中断一般分成三类：

1.CPU外部引起：I/O中断、时钟中断。

2.CPU内部或程序执行中引起的中断：程序非法操作、越界、溢出等。

3.使用了系统调用。

中断响应：硬件

中断处理:软件

**讲一讲操作系统的中断**

https://www.jianshu.com/p/eac05373f30f

1.外中断

2.内中断

 用户态到核心态的转换就是通过中断机制实现的，并且中断是唯一途径。

中断的本质：**发生中断就意味着需要操作系统介入，开展管理工作。**





**阻塞和非阻塞**

-知乎收藏

**同步和异步**

同步指的是一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。

异步指的是每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。





