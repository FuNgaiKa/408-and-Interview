**操作系统**

linux 命令查看cpu核数 内存情况
linux进程间通信的方式：
1.管道（有名 无名） 2.信号量 3.共享内存


![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16156543558297.jpg)

**关于操作系统和他的内核：**



**fork vfork clone的区别：**
1.fork后会将子进程放在队列前面，防止因为太多可以避免的写时复制而导致效率的下降。（执行顺序不可知，依赖于不同系统对fork的实现；多核机器上父子进程同时执行）
2.vfork保证子进程先执行，共享父进程的地址空间和页表项。

只完成了一件事：复制内部的内核数据结构。



3.clone创建线程，可以有选择的继承父进程内存



命名空间名和作用域分辨符：
nsl::a，nsl::b
 
孤儿进程 僵尸进程 及其危害？还有 守护进程。

处理僵尸进程的方法：
1.子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。
2.把父进程杀掉。父进程死后，僵尸进程成为"孤儿进程"，过继给进程init，init始终会负责清理僵尸进程。它产生的所有僵尸进程也跟着消失。

![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16156944044537.jpg)

linux的解压命令（常用的）：

![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16156972652857.jpg)

cpu大端和小端存储？
大端：数据高字节保存在内存低地址，数据低字节保存在内存的高地址中，地址由小向大增加，而数据从高位往低位放。
小端：高字节保存在高地址，低字节保存在低地址。

检测的代码：
int checkCPU(void)  
{  
    union  
    {  
        int a;  
        char b;  
    }c;  
    c.a = 1;  
    return (c.b == 1);  
}  
https://blog.csdn.net/Leafage_M/article/details/70880189
![image](https://user-images.githubusercontent.com/68175094/127894141-fff001ac-159f-46f3-9543-9dcf61f18ae0.png)



![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16156984841683.jpg)



**进程和线程的区别？**

-CyC2018

1.一个进程崩溃不会对其他进程造成影响；线程死掉会影响其他线程。

2.进程是CPU资源分配的基本单位，线程是CPU调度的基本单位。

3.进程开销:进程创建和撤销的时候开销大；线程开销小。

4.通信:线程间的通信方便；进程稍微复杂

5.进程编程调试简单；线程调试较复杂。

**多进程和多线程的使用场景**

多进程适合CPU密集型，多线程适合I/O密集型，单机多核分布式场景。

（公司很多个房子的例子）

![preview](https://pic3.zhimg.com/v2-add56b22280bb4d4ba61b27fdc4d8bc2_r.jpg)

**场景1--IO密集型应用：**

高速的CPU会停下来等待低速的外设，比如磁盘或网卡。如果不用多线程，基本上99%的CPU时间在等待。

如果等待期间，又去接受其它的用户请求，比如另一个http连接，多少可以利用一点闲置的CPU资源；



**场景2--CPU密集型应用：**

高速的CPU(内核)等待低速的总线，比如存取内存变量。与场景1同理。



其实多进程也能解决问题，但是性能开销、编码便利性(适用面)各有不同，这又是另一个话题了。



**使用多线程要注意什么呢？**

**线程和进程上下文切换？**

开销:进程>线程。

线程如何减少开销：

1.减少不必要的线程创建

2.协程。





进程三种状态：
1.就绪 2.阻塞 3.执行

运行到就绪：时间片到、高优先级。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JCakFGRjRoY3dvZmFTWkNGZVdadzlIN1M1Y3F0bjR3OEtYQXpTcVV2R3BTRFp3THBndlE0bGlhMENDSU1lQzVCSXBNcFE3dnJHWXAyVmZxdkw2Q05ldy82NDA?x-oss-process=image/format,png)



**进程和线程切换有什么步骤,开销怎么样**

https://blog.csdn.net/L13763338360/article/details/104961469/

**有了进程为什么要有线程？**

-牛客面试宝典（1）

进程同一时间只能干一件事；挂起；

线程优势：1.资源 2.切换效率 3.通信方式

（线程间通信容易一些）



**线程间通信（同步）**





**协程**

分时复用.

最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。

第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

https://www.liaoxuefeng.com/wiki/1016959663602400/1017968846697824



https://blog.csdn.net/qq_25424545/article/details/81529717

https://blog.csdn.net/u014630623/article/details/88914176

https://zhuanlan.zhihu.com/p/172471249

（自己得总结一下）：

类比多线程中的 线程切换 。但是不需要多线程的锁机制。

协程刚好可以解决上述2个问题。协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。**协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程**，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。

在有大量IO操作业务的情况下，我们采用协程替换线程，可以到达很好的效果，一是降低了系统内存（次要），二是减少了系统切换开销，因此系统的性能也会提升。

注意：

线程不需要这么多 -> 用线程池。

协程只是减少线程切换 -> 所以速度快。



**讲讲交换技术**

I/O速度比处理机速度慢得多。为了防止所有进程阻塞等待I/O，将一部分进程换到外存，腾出内存空间（进程状态变成挂起）。

活动阻塞、静止阻塞。

活动就绪、静止就绪。



**讲一讲进程控制块：**
操作系统通过进程控制块来对进程进行控制和管理。PCB通常在系统内存中占用一块连续的分区，存放着os用于描述、控制进程情况的全部信息。

为什么需要CPU调度？
CPU调度的目标是在任何时候都有某些进程在运行，是CPU使用率最大化。  同一时刻 只有一个进程占有CPU资源，但一个进程在等待IO时等等一些阻塞进程的动作时，CPU就回空闲出来，这时候，我们应该让这个阻塞的进程让出CPU资源，让其他已经处于就绪状态的进程执行。这样就可以使CPU使用率最大化。

**什么是死锁？**

在多道程序环境下，多个进程可能竞争一定数量的资源，某个进程申请资源，如果这时这个资源不可用，那么这个进程就进入等待状态。如果所申请的资源被其他等待进程占有，那么该等待进程可能再也无法改变其状态，一直等待下去，这种情况称之为 死锁。

**死锁的四个条件：**
1.互斥 2.不可抢占 3.占有且申请（不可剥夺，只能在使用后自己释放） 4.循环等待

**cache的作用？**
cache是处于 CPU寄存器 和 内存之间的一层缓存，用来加快CPU的取指速率， 使用时： CPU需要数据时，首先会查找cache中有没有需要的数据，如果有，则取走，如果没有，则查询内存，并将数据更新到缓存中，以供下次取指。

***内存的段页式管理的优缺点？***
1.段式存储管理（逻辑地址）
将程序的地址空间划分为若干个段，每个进程都有一个二维（段名 段内地址）的地址空间，程序通过分段来划分为多个模块。
优点：没有内碎片。

2.页式存储管理（一维）（物理地址）
程序的逻辑地址划分为固定大小的页，物理内存则为页框。
优点：没有外碎片，一个程序不必连续存放。便于更改内存占用的空间大小。

页是信息的物理单位，段是信息的逻辑单位。页大小由系统决定，段大小决定于用户编写的程序。

**页表**：帧号

3.段页式存储管理
地址结构：段号，段内页号，页内地址
缺点：开销变大，执行速度下降

**段表**：界限、基地址。

内碎片（已分配） 外碎片（未分配）

**注意**：在编译过程之中建立的多个表，动态增长。如果使用分页的话，可能会导致覆盖问题。

内存：
1.虚拟内存
经常被分割成多个物理内存碎片，还有部分占时存储在外部磁盘存储器上面

2.物理内存
物理地址被分成离散的单元，称为页

信号量：
sem_wait 减少空位
Sem_post 增加空位





![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16157151183692.jpg)

就绪状态：进程缺少cpu 等待状态：进程需要其他资源（除了cpu）或等待某一事件。

用户态
核心态
https://www.cnblogs.com/Allen-rg/p/7171105.html

段式存储管理和页式存储管理：

![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16157157199137.jpg)

操作系统进程调度的策略：

![](E:\QQis_here\1264947688\FileRecv\MobileFile\media\16157158537922.jpg)



**线程同步（通信）方式：**
1.互斥量

2.信号量

3.临界区

4.事件（信号）



**进程间通信**

https://blog.csdn.net/qq_38880380/article/details/78527115

本地的进程间通信（IPC）有很多种方式，但可以总结为：

1.管道

2.系统IPC：消息队列，

信号量（实际上是一个计数器，用于实现进程间的互斥和同步，而不是用于存储进程间通信数据），

共享内存（最快的IPC，因为进程是对内存的直接读取，经常和信号量一起使用，来完成同步和通信）

3.套接字socket（用于不同主机之间的进程通信）





**同步操作和异步操作**
**阻塞和非阻塞操作**

同步指的是一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。



异步指的是每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。



**进程间同步**

1.信号量和PV操作

2.条件临界区

3.管程

（同步和通信联系紧密）

**进程内（线程间）同步**

![image-20210319182749356](file://C:\Users\FuNgaiKa\AppData\Roaming\Typora\typora-user-images\image-20210319182749356.png?lastModify=1616166873)

互斥量、读写锁、信号量、临界区、条件变量

**进程互斥**

临界区、peterson算法、lamport算法

**进程间通信和线程间通信**

https://blog.csdn.net/feelinghappy/article/details/108087038



**IO多路复用的三种机制Select，Poll，Epoll的区别**



**Linux文件系统**

https://zhuanlan.zhihu.com/p/128669031



**Linux的一些指令**

解压命令       unzip 文件名.zip  /  tar -xvf 文件名.tar.gz
查看连接状态  netstat
查看运行中的进程  ps
杀死运行中的进程   kill  pid
查看内存  free
查看CPU占用  top
查看端口  netstat  -anp | grep 端口号

https://www.runoob.com/w3cnote/linux-common-command-2.html







**关于文件**

https://liuyehcf.github.io/2017/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F1/

文件的典型存储介质：磁盘。

访问磁盘的时间主要是寻道时间。

寻道时间：***\*磁头\****从开始移动到数据所在**磁道**所需要的时间。寻道时间越短，I/O操作越快。（磁道，扇区，柱面）



![image](http://static.oschina.net/uploads/img/201312/24091906_1mMg.png)



磁盘调度算法：

1.先来先服务FCFS

2.最短寻道时间优先SSTF

3.电梯算法SCAN



**局部性原理**

1.时间局限性

2.空间局限性



（虚拟）**内存调度**

关于调换页面置换的算法。

1.最佳置换

2.先进先出

3.最近最久未使用（LRU）



**CPU调度**

1.先进先出

2.最短作业（进程）优先（抢占、非抢占）

3.优先级调度（问题：无穷阻塞，解决方法：老化）

4.轮转





**linux的shell脚本删除一个月前的日志**

1.根据文件修改日期

2.根据文件名

3.定期执行脚本



**互斥锁（mutex）和读写锁的机制、区别？**

互斥锁：只有一个线程访问，其他睡眠

读写锁：写者优先；多线程读，一线程写；写的时候不可以读。

自旋锁：区别互斥锁的睡眠——原地自旋直到锁被释放。

条件变量。(通常和互斥锁一起使用)（类似轮询）

**说说你用到过的锁**

https://www.zhihu.com/question/66733477





生产者消费者问题：互斥锁、条件变量。



**区分内存泄漏和内存溢出**

都可以因为内存未能及时回收而产生。



**系统调用**

管态：核心态

目态：用户态

访问系统核心功能，或者危险的、权限高的指令，通过接口使用系统调用。

**请介绍一下操作系统的中断**

中断一般分成三类：

1.CPU外部引起：I/O中断、时钟中断。

2.CPU内部或程序执行中引起的中断：程序非法操作、越界、溢出等。

3.使用了系统调用。

中断响应：硬件

中断处理:软件

**讲一讲操作系统的中断**

https://www.jianshu.com/p/eac05373f30f

1.外中断

2.内中断

 用户态到核心态的转换就是通过中断机制实现的，并且中断是唯一途径。

中断的本质：**发生中断就意味着需要操作系统介入，开展管理工作。**





**阻塞和非阻塞**

程序等待结果时候的状态

-知乎收藏

**同步和异步**

消息回传的方式。

同步指的是一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。

异步指的是每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。



**线程安全**

https://blog.csdn.net/csdnnews/article/details/82321777

锁:解决死锁,多线程访问冲突的问题.



**while（）的cpu占用的问题**

sleep（1）完美解决。

https://blog.csdn.net/WuEnYou/article/details/78980375



**linux从汇编到输出的过程**

https://blog.csdn.net/dongqinliuzi/article/details/39497559?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=1328760.2088.16171856851535325&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control



**printf是如何将字符输出到显示器上的(IO与显示器)**

https://blog.csdn.net/jump_into_zehe/article/details/106175519



**死锁 和 饥饿**

**寻道时间 和 旋转延迟**



**进程隔离的实现方式？**

在操作系统中，进程与进程间的内存和数据都是不共享的。两个进程就好像大海中相互独立的两个岛屿，各自生活在互相平行的两个世界中，互不干扰，各自为政。这样做的目的，是为了避免进程间相互操作数据的现象发生，从而引起各自的安全问题。为了实现进程隔离，采用了虚拟地址空间，两个进程各自的虚拟地址不同，从逻辑上来实现彼此间的隔离。

作者：bug樱樱
链接：https://www.jianshu.com/p/63828d891f31
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



**C/C++ Sleep()函数和wait()函数的区别**

https://blog.csdn.net/weixin_42709632/article/details/105175396

睡眠是自动完成

挂起恢复需要主动完成



**读者-作者问题**

与**哲学家就餐**问题相联系

读者和写者都有可能饥饿 （黑书P187）锁中锁



**linux软链接硬链接**

用户数据 (user data) 与元数据 (metadata)

https://blog.csdn.net/weixin_44023707/article/details/93787739

https://www.linuxprobe.com/soft-and-hard-links.html

inode号

![软链接和硬链接详解软链接和硬链接详解](https://www.linuxprobe.com/wp-content/uploads/2016/05/soft-link.jpg)



1.软链接：类似于 Windows 系统中给文件创建快捷方式，即产生一个特殊文件，该文件用来指向另一个文件，此链接方式同样适用于目录。(间接指向)
2.硬链接：我们知道，文件的基本信息都存储在 inode 中，而硬链接指的就是给一个文件的 inode 分配多个文件名，通过任何一个文件名，都可以找到此文件的 inode，从而读取该文件的数据信息。

inode叫做索引节点号，这是Linux文件系统管理文件的方式。在建立文件系统时，会建立一个索引节点表，里面包含一定数量的索引节点。每当建立一个文件时，就会为他分配一个索引节点号，相当于文件的地址。

cat file

ln myfile hard

ls -li



**线程安全**

https://blog.csdn.net/csdnnews/article/details/82321777

共享数据段不安全



**操作系统常见的进程调度算法**

1.先进先出FIFO

　　2.时间片轮转法

　　3.多级反馈队列算法

　　4.最短进程优先

　　5.最短剩余时间优先

　　6.最高响应比优先

　　7.多级反馈队列调度算法



**内核、shell、操作系统的关系**

![img](https://pic4.zhimg.com/80/v2-8ecce2b2529d35d5ef40cc8591948a23_1440w.jpg)





**多线程编程的核心概念（3个）**

1.原子性

2.可见性

3.顺序性



**用户态和内核态的理解和区别？**

特权级别



用户态到内核态的3种方式：

1.系统调用（这是用户态进程主动要求切换到内核态的一种方式。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。）

2.异常

3.外围设备的中断



**线程唤醒**

惊群效应，即当某一资源可用时，多个进程/线程会惊醒，竞争资源，导致n-1个进程/线程做了无效的调度，上下文切换，cpu瞬时增高。

https://blog.csdn.net/kpengk/article/details/106875074


**高并发**
高并发：高并发指的是是一种系统运行过程中遇到的一种“短时间内遇到大量操作请求”的情况，主要发生在web系统集中大量访问或者socket端口集中性收到大量请求（例如：12306的抢票情况；天猫双十一活动）。该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作等。如果高并发处理不好，不仅仅降低了用户的体验度（请求响应时间过长），同时可能导致系统宕机，严重的甚至导致OOM异常，系统停止工作等。如果要想系统能够适应高并发状态，则需要从各个方面进行系统优化，包括，硬件、网络、系统架构、开发语言的选取、数据结构的运用、算法优化、数据库优化……。

**多进程和多线程**
下面是本人从知乎-pansz上转载的一个答案，非常通俗地回答了这个问题。

单进程单线程：一个人在一个桌子上吃菜。
单进程多线程：多个人在同一个桌子上一起吃菜。
多进程单线程：多个人每个人在自己的桌子上吃菜。
多线程的问题是多个人同时吃一道菜的时候容易发生争抢，例如两个人同时夹一个菜，一个人刚伸出筷子，结果伸到的时候已经被夹走菜了。。。此时就必须等一个人夹一口之后，在还给另外一个人夹菜，也就是说资源共享就会发生冲突争抢。

1。对于 Windows 系统来说，【开桌子】的开销很大，因此 Windows 鼓励大家在一个桌子上吃菜。因此 Windows 多线程学习重点是要大量面对资源争抢与同步方面的问题。

2。对于 Linux 系统来说，【开桌子】的开销很小，因此 Linux 鼓励大家尽量每个人都开自己的桌子吃菜。这带来新的问题是：坐在两张不同的桌子上，说话不方便。因此，Linux 下的学习重点大家要学习进程间通讯的方法。

**协程**
“子程序就是协程的一种特例。”
https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272

