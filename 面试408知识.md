*计算机网络*
五层：应用、传输、网络、链路、物理
OSI七层：应用层、表示层、回话、传输、网络、数据链路、物理。

TCP和UDP的区别？
1.面向连接 2。面向报文 面向字节流 2.传输速度 3.安全性 4.传输数据的格式：报文段 数据报 

udp能否实现可靠连接？
可以。将可靠传输服务转移到应用层中实现。seq/ack机制；发送接收缓冲区：超时重传。

三次握手：SYN ACK

四次挥手：FIN ACK 第二次握手之后B可以继续向A分发数据
四次挥手的time_wait状态什么时候存在？为什么存在？为什么要等待两个时间周期？
答：不能保证最后的ack到达b 如果最后的ack丢失 b有发起fin重传的可能。

单播 多播 广播（一个服务端）

TCP和UDP能否发送0字节的数据包？TCP发送后接收方不会收到；UDP发送后，则可以。

**关于TCP粘包**

https://blog.csdn.net/weixin_41047704/article/details/85340311

1.流量控制：
解决*流水线*的差错恢复（关于发送序号和ACK回去给客户端）：
1.回退N步（GBN）
2.选择重传（SR）
（两者都有超时）

TCP的差错恢复（重传，关于发送ACK）：
1.超时间隔加倍
2.快速重传 3次冗余ACK

2.拥塞控制：
TCP的拥塞机制：（加性增 乘性减：AIMD）
1.慢启动
2.拥塞避免
3.快速恢复

MSS：最大报文段长度

MTU：最大传输单元（最后发送出去的报文大小）
（因为以太网数据帧的长度必须在46-1500字节之间 这个1500字节被称为链路层的MTU）

MTU包含MSS

描述HTTP协议：
超文本传输协议。应用层协议。使用tcp作为其传输层。
工作原理：

![](media/16156484600640.jpg)


![](media/16156487457359.jpg)


*DNS域名系统工作原理？*
dns要做的就是在用户输入域名之后，先到dns服务器查询ip地址，然后通过ip地址来访问站点。简单来说，就是将主机名解析为ip地址。

dns域名解析过程：
1.递归查询
2.迭代查询
直到得到最终的ip地址，再返回给主机。

**回顾：Web页面请求的过程**
1.便携机与网络相连，运行DHCP协议获得IP地址。
2.DHCP客户记录下它的IP地址和它的DNS服务器的IP地址
3.获得IP地址就可以开始键入。尝试生成TCP套接字发送HTTP请求。
不知道网址的IP，需要用到DNS查询。
期间不知道MAC地址的话使用ARP协议。
4.获得目的IP之后，开始先TCP三次握手。
5.发送HTTP请求报文，收到HTTP响应报文。读取到网页。
（后面还有释放tcp链接）

**http协议**

https://www.cnblogs.com/an-wen/p/11180076.html

1. http协议支持客户端/服务端模式，也是一种请求/响应模式的协议。
2. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。
3. 灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。
4. 无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。
5. 无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。

http协议是应用层协议，基于tcp/ip协议之上。
http是无状态保存的协议。每次连接只处理一个请求。
http的状态码：
2xx 成功；3xx 重定向；4xx 客户端错误；5xx 服务端错误。

GET和POST的区别：
get参数通过url传递 post参数被放在请求体
get在url传递的参数有限 post没有这个要求
get参数直接暴露在url中 没有post安全
get请求只能进行url编码 post支持多种编码方式
get产生一个TCP数据包 （header和data一起）post产生两个（分开）。

**http和https的区别**

https协议需要到CA申请证书，可能需要一定的费用
http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密传输协议
http和https采用不同的连接方式，http用80端口，https用443端口
http连接简单，无状态。https使由http+SSL构建的可进行加密传输、身份认证的网络协议

**http传输步骤**

\1. 客户端连接到Web服务器
一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，[http://www.baidu.com](http://www.baidu.com/)。

\2. 发送HTTP请求
通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。

\3. 服务器接受请求并返回HTTP响应
Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。

\4. 释放连接TCP连接
若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

\5. 客户端浏览器解析HTML内容
客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

![](media/16156537933854.jpg)

**URL**

统一资源定位符。



tcp：
流量控制：滑动窗口
拥塞控制：慢启动、拥塞避免、快速回复。

tcp为什么是可靠的？怎么保证？
校验和，序列号，定时器，确认问答，快重传（三个冗余ACK则重新发送）



每台主机ARP缓冲区里面有ARP列表。本地网发起ARP请求的广播包。如果目的ip与自己的ip地址一致，就发送一个ARP响应包（单播应答）。

ICMP协议：因特网控制信息协议
功能：1.确认ip包是否成功到达目标地址
2.通知在发送过程中ip包被丢弃的原因



*算法*

LRU算法。
多个有序链表合并。（lc）

*操作系统*
linux 命令查看cpu核数 内存情况
linux进程间通信的方式：
1.管道（有名 无名） 2.信号量 3.共享内存


![](media/16156543558297.jpg)

关于操作系统和他的内核：

![](media/16156548141355.jpg)


![](media/16156549630693.jpg)

fork vfork clone的区别：
fork后会将子进程放在队列前面，防止因为太多可以避免的写时复制而导致效率的下降。
vfork共享父进程空间
clone创建线程，可以有选择的继承父进程内存

命名空间名和作用域分辨符：
nsl::a，nsl::b

孤儿进程 僵尸进程 及其危害？

![](media/16156944044537.jpg)

linux的解压命令（常用的）：

![](media/16156972652857.jpg)

cpu大端和小端存储？
大端：数据高字节保存在内存低地址，数据低字节保存在内存的高地址中，地址由小向大增加，而数据从高位往低位放。
小端：高字节保存在高地址，低字节保存在低地址。

![](media/16156984841683.jpg)




进程和线程的区别？

![](media/16152990107454.jpg)

讲一讲进程控制块：
操作系统通过进程控制块来对进程进行控制和管理。PCB通常在系统内存中占用一块连续的分区，存放着os用于描述、控制进程情况的全部信息。

为什么需要CPU调度？
CPU调度的目标是在任何时候都有某些进程在运行，是CPU使用率最大化。  同一时刻 只有一个进程占有CPU资源，但一个进程在等待IO时等等一些阻塞进程的动作时，CPU就回空闲出来，这时候，我们应该让这个阻塞的进程让出CPU资源，让其他已经处于就绪状态的进程执行。这样就可以使CPU使用率最大化。

什么是死锁？
在多道程序环境下，多个进程可能竞争一定数量的资源，某个进程申请资源，如果这时这个资源不可用，那么这个进程就进入等待状态。如果所申请的资源被其他等待进程占有，那么该等待进程可能再也无法改变其状态，一直等待下去，这种情况称之为 死锁。

死锁的四个条件：
1.互斥 2.不可抢占 3.占有且申请 4.循环等待

cache的作用？
cache是处于 CPU寄存器 和 内存之间的一层缓存，用来加快CPU的取指速率， 使用时： CPU需要数据时，首先会查找cache中有没有需要的数据，如果有，则取走，如果没有，则查询内存，并将数据更新到缓存中，以供下次取指。

*内存的段页式管理的优缺点？*
1.段式存储管理（逻辑地址）
将程序的地址空间划分为若干个段，每个进程都有一个二维（段名 段内地址）的地址空间，程序通过分段来划分为多个模块。
优点：没有内碎片。


2.页式存储管理（一维）（物理地址）
程序的逻辑地址划分为固定大小的页，物理内存则为页框。
优点：没有外碎片，一个程序不必连续存放。便于更改内存占用的空间大小。

页是信息的物理单位，段是信息的逻辑单位。页大小由系统决定，段大小决定于用户编写的程序。

3.段页式存储管理
地址结构：段号，段内页号，页内地址
缺点：开销变大，执行速度下降

内碎片（已分配） 外碎片（未分配）

内存：
1.虚拟内存
经常被分割成多个物理内存碎片，还有部分占时存储在外部磁盘存储器上面

2.物理内存
物理地址被分成离散的单元，称为页

信号量：
sem_wait 减少空位
Sem_post 增加空位

线程同步的方式：
1.互斥量
2.信号量

进程三种状态：
1.就绪 2.阻塞 3.执行

![](media/16157151183692.jpg)

就绪状态：进程缺少cpu 等待状态：进程需要其他资源（除了cpu）或等待某一事件。

用户态
核心态

段式存储管理和页式存储管理：

![](media/16157157199137.jpg)

操作系统进程调度的策略：

![](media/16157158537922.jpg)



*数据结构*
二叉树：给出中序和后序 求前序（leetcode）



**常见面试题总结**

https://blog.csdn.net/qq_40769893/article/details/88367706
