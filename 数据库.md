*主键*

sql：一种语言
mysql：数据库管理软件

sql对大小写不敏感：select==SELECT

*是选取所有列的快捷方式

select distinct 用于返回唯一不同的值（所有列的值都相同时，两个行才算是相同）

where 语句

order by：
根据指定的列对结果集进行排序
默认按照“升序”进行排序

ASC：升序
DESC：降序
LIMIT：限制返回的行数

insert into：
记得先添加主键

update：修改表中的数据
UPDATE world.country SET Name ='xiaoweige' WHERE Code='ABC';
修改了name这里

delete：
用于删除表中的行

*sql分类*
DDL：数据定义语言
主要功能是定义数据库对象
核心指令：create,alter,drop

DML：数据操纵语言
主要功能：访问数据
insert，update，select，delete（增删查改）

TCL事物控制语言
DCL数据控制语言

*sql函数*


![](media/16153549368833.jpg)

AS：
select 列名 from 表名 as 别名；

主键 超键 候选键 外键

sql中join里面：on和where的区别

*一条sql语句执行得很慢的原因*
两种情况：
1.数据库刷新脏页 遇到锁
2.没有用到索引 数据库选错了索引

数据库一个逻辑执行单元如何才能被称得上是一个事务？必须满足的性质？


![](media/16154610815940.jpg)

内连接、外连接。
左外连接、右外连接、全外连接。

![img](https://image-static.segmentfault.com/276/780/2767807589-5c122586a23c4_fix732)



**索引**

**主键、超键、候选键、外键**

https://blog.csdn.net/jerry11112/article/details/78160771



**sql语句执行很慢的原因**

https://zhuanlan.zhihu.com/p/62941196

-帅地



**非主键索引、主键索引**
主键索引:聚簇索引

https://mp.weixin.qq.com/s/RemJcqPIvLArmfWIhoaZ1g



**聚集索引\非聚集索引**

字典的按拼音和按偏旁。



聚集索引不适用于：

   • 频繁更改的列 。这将导致整行移动（因为 SQL Server 必须按物理顺序保留行中的数据值）。这一点要特别注意，因为在大数据量事务处理系统中数据是易失的。



**.为什么一般情况下，我们建表的时候都会使用一个自增的id来作为我们的主键？**

　　InnoDB中表中的数据是直接存储在主键聚簇索引的叶子节点中的，每插入一条记录，其实都是增加一个叶子节点，如果主键是顺序的，只需要把新增的一条记录存储在上一条记录的后面，当页达到最大填充因子的时候，下一跳记录就会写入新的页中，这种情况下，主键页就会近似于被顺序的记录填满。

　　若表的主键不是顺序的id，而是**无规律数据**，比如字符串，InnoDB无法加单的把一行记录插入到索引的最后，而是需要找一个合适的位置（已有数据的中间位置），甚至产生大量的页分裂并且移动大量数据，在寻找合适位置进行插入时，目标页可能不在内存中，这就导致了大量的随机IO操作，影响插入效率。除此之外，大量的页分裂会导致大量的内存碎片。





**为什么使用B+树而不是B树？**

https://blog.csdn.net/zhoucheng05_13/article/details/79825246

使用B+树的好处：
由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。
B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间
使用B树的好处：
B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。

数据库为什么使用B+树而不是B树？
因为就是上面提到的B+树的好处。数据库的数据读取都是需要进行代价巨大的磁盘IO操作，因此，更快地缩小范围和更少的读取次数是数据库需要关注的重点。而B+树在这些点上比B树做的更好。这就是为什么数据库要选用B+树作为底层实现。
————————————————
版权声明：本文为CSDN博主「Star_Ship」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zhoucheng05_13/article/details/79825246



**B+树与红黑树的比较**

1.B+树有更低的树高

2.磁盘访问原理（与寻道有关）

3.磁盘预读特性（相邻的节点也能预读的时候预先载入）





**事务**

指的是满足ACID特性的一组操作，通过commit提交一个事务，也可以用rollback进行回滚。



**ACID**

1.原子性 Atomicity

2.一致性 Consistency

3.隔离性Isolation 

-上面应对的时执行结果正确的问题

4.持久性（Durability） 应对的是系统崩溃问题



**并发一致性问题**

1.丢失修改

2.读脏数据（写完数据后回滚了）

3.不可重复读

3.幻影读（中间插入）



**封锁协议（解决：并发一致性问题）**

1.一级封锁协议：不能有两个事务对同一个数据进行修改。

2.二级

3.三级



**隔离级别**

1.未提交读

2.提交读

3.可重复读

4.可串行化

（用来解决并发一致性问题）



**MVCC：多版本并发控制**

undo日志：回滚日志

redo日志：重做日志

用于实现提交读和可重复读两种隔离级别。

版本快照：为了解决脏读和不可重复读的问题，MVCC规定只能读取已经提交的快照。

**版本号**

系统版本号：SYS_ID

事务版本号:TRX_ID



**READVIEW结构**

包含当前系统未提交的事务列表TRX_IDs

以及列表的最小值和最大值。

（三种分类讨论）

根据undo log的回滚指针ROLL_PTR找到下一个快照，再进行上面的判断。



**Next-Key Locks**

使用MVCC和Next-Key Locks解决幻影读问题。

1.锁定一个记录上面的索引（Record Locks）

2.锁定索引之间的间隙，但不包含索引本身。（Gap Locks）

NKL是两个的结合



**为什么还需要二级索引？**

1.占用空间更少





**几种数据库引擎的比较**

https://www.jianshu.com/p/4bb9f78b4f6d

**各种引擎的比较**

https://blog.csdn.net/qq_31964815/article/details/70256223

https://blog.csdn.net/zycxnanwang/article/details/106034613

innodb（聚集索引）和myisam（非聚集索引）都使用b+树。



比较的方面：事务、并发（锁）、外键、备份、崩溃恢复。

**innoDB**：

索引存放的是直接的数据文件

提供外键、事务、回滚；支持行级锁，也支持表级锁。主索引是聚簇索引（主键索引）。

是mysql的的默认引擎。为巨大数据量的最大性能设计。

“自适应哈希索引”：当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

支持在线热备份。

**myISAM**：

索引存放的是保存数据记录的地址（在MyISAM中，**主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复**。）

不提供外键和事务；支持的是表级锁。

和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。



**外键作用**

1.数据完整性、一致性

2.为了一张表记录的数据不要太过冗余

3.使得两张表关联



**在 InnoDB 引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表？什么时候只锁住一行呢？**

InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现的特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁。
————————————————
原文链接：https://blog.csdn.net/qq_36071795/article/details/83869042



**避免死锁的方法**

有多种方法可以避免死锁，这里只介绍常见的三种：

如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低发生死锁的可能性；

在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；

对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。



**死锁**

当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引；另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。

发生死锁后，InnoDB 一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。



**封锁类型：**

1.读写锁

2.共享锁



**关系型数据库设计理论**

1.函数依赖

部分函数依赖；完全函数依赖；传递函数依赖

2.异常

3.范式：为了解决以上提到的4种异常



**主要有四种异常**：（不符合范式的缘故）

1.冗余数据（查 重复出现

2.修改异常（改

3.删除异常（删

4.插入异常（增



**范式**

码（类似主键）；主属性；非主属性。

1NF:属性不可分。

2NF:非主属性没有**部分依赖**。

3NF:不存在**传递函数依赖**

https://www.zhihu.com/question/24696366/answer/29189700



**关于乐观锁和悲观锁**

https://www.jianshu.com/p/d2ac26ca6525

悲观锁:读写锁，又分为共享锁和排他锁，其实就是读锁和写锁。

（先取锁，再访问）

乐观锁：版本号控制，即为读取数据库时读取version，提交前再读取一次version。如果不一样，则不更新，让用户重新操作。



**索引的优点**

1.减少扫描的数据行数

2.避免排序和分组，避免创建临时表

3.把随机IO变为顺序IO



**复制**

1.主从复制

三个线程：binlog、IO和SQL线程。

- **binlog 线程** ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
- **I/O 线程** ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
- **SQL 线程** ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。



**读写分离**

主服务器：写操作以及实时性要求比较高的读操作，

从服务器：处理读操作。

读写分离能提高性能的**原因**在于：

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。



