*cpp篇：2*

**复习宝典**

-牛客



STL：
**vector的扩容** 

它是一个动态数组 底层为连续的线性内存空间

**vector内存申请和释放**

拷贝构造函数



.size() .capacity()的区别 成倍扩容

vector使用的注意点：插入元素时元素的移动 是否需要扩容

c++重载和重写的区别：是否发生在同一个类 virtual关键字
重定义：父类同名函数被隐藏 子类对象调用函数时，如果不指定类作用符，就只会调用子类同名函数。（注意，成员变量名相同的时候，也会被隐藏）

*cpp5个内存分区*
1.堆区 2.栈区 3.全局区 4.文字常量区 5.程序代码区

堆和栈区别：1.申请方式 2.申请效率 3.存放的内容

字符数组与字符指针的性质：
1.更改指向的方向  3.指针可以进行++运算（改地址） 4.指针可以串连接和串复制 （如果需要复制 字符数组先得自己开辟位置）

浅拷贝和深拷贝的问题：关于内存空间
当出现指针变量的时候，最好使用深拷贝，避免内存空间多次释放的问题出现。

大端小端：高尾端 低尾端



数据高位存放在低地址，数据低位存放在高地址。


出现野指针的情形讨论
1.定义的时候没有初始化 2.delete释放后没有置为null 3.指针操作超过了变量作用范围

野指针和悬挂指针都是指向垃圾内存。

指针悬挂问题；通用指针：可以指向任何类型的变量，类型用（void*）表示，因此也叫做void指针。


*cpp篇：3*
c++的三大特性：封装，继承，多态

final关键字修饰类或者成员函数：修饰的成员不能重写或者修改。

**多态的含义：**

基类的指针指向或者绑定到派生类的对象 使得基类指针呈现不同的表现方式

**多态的实现和应用场景**

多态体现在运行和编译两个方面：
1.程序运行时的多态性通过继承和虚函数来实现（动态多态）
2.程序编译时的多态性通过函数和运算符的重载 来体现（静态多态）

虚函数表与其指针：表里保存了虚函数地址 表保存在虚函数类实例对象的内存空间中，虚函数表的指针保存在对象实例的最前面的位置。
虚函数表是在编译阶段建立的，程序的编译过程中会将虚函数的地址放在虚函数表中。

**多态满足的三个条件**

1.有继承

2.基类指针指向子类

3.有重写



***虚继承*：解决多重继承中命名冲突和数据冗余**

虚基类的目的是为了让某个子类作出声明，承诺愿意共享它的基类，这个被共享的基类就被称为虚基类。

**int const* a（即为int const（*a））;**

int *const a
（即为int * （const a））; 一个是指向的值不变（常量指针）；一个是保存的地址（比如保存b的地址）不变（指针常量）

还有一种：const int *const a;指向常量的常指针。

类的const成员变量必须在构造函数的参数初始化列表中进行初始化 或者在声明的时候就直接赋值。

类内的静态变量如何初始化？类外int test::a=1;注意没有static

**析构函数一般写成虚函数的原因？**
防止内存泄漏。如果不将基类的析构函数定义成虚函数，就只能将基类的成员所占的空间释放掉，派生类的成员无法释放，造成泄漏。

**构造函数为什么一般不定义为虚函数？**
1.实例化对象才可以调用虚函数。此时对象都还没有创建，虚函数表存在，但是虚函数的指针还不存在 

2. 虚函数本来是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数调用，而构造函数是创建对象时自动调用的，这两者不同。
3. 虚函数对应一个vtable，这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。





**构造函数或者析构函数中调用虚函数会怎么样？**
先是调用基类的虚函数，从而对象变成了基类类型，不能达到多态的效果。

纯虚函数？
抽象基类 类中只有接口 没有具体的实现方法，以便派生类根据需要对它进行定义。

继承纯虚函数的派生类：抽象类与实例化对象
抽象类必须用作派生其他类的基类

子类必须继承父类的纯虚函数 实现后， 才可以创建对象

静态绑定和动态绑定：程序在 编译 过程中确定对象的类型
                在 运行 期间确定对象的类型
                
静态类型和动态类型：静态类型不能修改，动态可以修改。
要想实现多态，必须进行动态绑定。在继承体系中，只有虚函数是动态绑定，其他都是静态绑定。


继承体系中 只有虚函数是动态绑定

编译时多态：发生在模版和函数重载（泛型编程） 
运行时多态：继承体系中 虚函数

显式接口：运行时多态中 调用的函数
隐式接口：无法确定来源的接口 比如函数重载和模版

编译时多态和运行时多态的区别：发生在运行过程和编译过程

引用 能否实现动态绑定？为什么可以实现？
可以。因为对象的类型是确定的，引用时在运行阶段根据他们绑定的具体对象的类型确定。


深拷贝和浅拷贝的区别？
如果资源发生了重新分配就是深拷贝，如果对象和原对象占用同一块内存，则是浅拷贝。


介绍c++所有的构造函数。
1.默认构造函数 2.拷贝构造函数 3.一般构造函数 4.赋值构造函数（重载了赋值运算符） 5.析构函数

默认生成的拷贝构造函数都是*浅拷贝*的

拷贝构造函数和赋值构造函数的区别
1.赋值的返回类型是该类的引用类型，而拷贝构造函数没有返回类型。
2.拷贝是：在函数内直接申请空间然后给相应的变量赋值。调用赋值时，需要将目标对象的内存空间（heap）释放掉，重新申请空间，再进行拷贝。

什么情况下会调用拷贝构造函数（三种情况）
1.类的赋值
2.形参实参
3.作为函数返回值。


*cpp：5*
内存泄漏的定义：由于疏忽或者错误，未能释放掉不再使用的内存。失去了对这块内存的控制 因此造成了内存的浪费

解决内存泄漏的方法：智能指针

智能指针：共享指针 独占指针 弱指针

弱指针怎么解决共享指针的循环引用问题？

模版：函数、类模版
使用场景：数据类型与算法相分离的泛型编程

在类中，成员初始化列表的概念。为什么用成员初始化列表会快一些？
我的理解是 先调用的是默认构造函数创建对象

**C11新特性：**

lambda表达式 模版 泛型编程（通过模版） 智能指针 emplace



！注意lambda

**c风格的强制转换（4种）**
c++风格的四种强制转换
1.static_cast
2.const_cast
3.reinterpret_cast
4.dynamic_cast（这一种是程序运行时处理的 其他三种都是编译时完成的）

*cpp：6*
指针函数 没有括号：本质上是函数，返回值是一个指针。
函数指针 有括号 ；本质是一个指针，指向一个函数

构造函数的调用次数：
A t[5]：长度是5，所以会调用5次
A *p[5]：存放的是指向A类型的对象的指针！所以不会调用构造函数

析构函数和构造函数的调用顺序：例子


auto：根据右边的初始值value推导出var的类型；要求变量必须初始化 定义变量的时候必须赋值

不能重载的5种运算符：1. . 2. .* 3. :: 4. Sizeof 5. ?:

运算符重载为类的成员函数还是类的友元函数？
都可以。


静态函数能否定义成虚函数？为什么？
不能。1.静态成员不属于任何类对象或者实例，加上virtual也没有意义。2.静态成员函数没有this指针。无法访问虚函数表的指针。

静态函数不能为const函数的原因？
没有this指针，const修饰static没有意义。

封装、继承、多态、虚函数。

![](media/16157010826242.jpg)

*虚函数表*：
虚函数的地址存放在虚函数表中，运行时期多态通过虚函数和虚函数表来实现。类的对象内部有指向类内部的虚函数表地址的指针，利用这个指针调用虚函数。


*预编译*：预处理
#include：将xxx文件的全部内容插入此处。
#define 宏定义。 （注意与const的区别）

1.有无类型检查 2.编译预处理阶段 编译运行阶段 3.const不能重定义 define可以通过#undef取消字符的定义

*其他*
实现多态的三点：
1.最少两个类 而且必须是继承
2.函数必须是虚函数（同名 同参数 同返回类型）
3.通过基类的指针或者引用来实现

*如何通过虚表实现多态？*
有覆盖的时候，覆盖的子类替代原先父类虚表的位置。
多继承有覆盖的时候，覆盖的子类会替代所有父类同名虚函数在虚表中的位置，其余子类虚表紧跟第一个父类的虚表。


值传递
引用传递：d的地址就是b的地址
地址传递：只要变量不被销毁 这个地址不能改变

为什么快速排序时间复杂度是Ｏ(nlogn)？

时间复杂度相同，为什么快速排序一般优于归并排序？
思路：原地操作 不需要辅助数组；相邻位置的内存比分散的内存，访问更快 特别是将列表均匀的分成两半时

c++四种转换形式：
去const属性用const_cast
基本类型转换用static_cast （跟强制转换相比 更安全）
多态类之间的类型转换用dynamic_cast
不同类型的指针类型转换用reinterpret_cast

可以通过子类对象调用父类的成员函数吗？
思路：public 不可以；private。 protected 可以。

friendly 和 protected：前者 子类不能调用 后者是可以的。


*虚函数表的原理*

快速排序什么时候退化为冒泡排序？
思路：当序列基本有序的时候 同时因为排序过程中可能改变相等元素的原始位置 所以快速排序是不稳定的排序算法

如果父类成员函数为虚函数，子类是可以调用的。
B b;
b.A::func();
（不在虚表找 直接调用父类的）

**new和malloc的区别：**
1.new是cpp的运算符 malloc是cpp标准函数
2.new更加智能 底层是malloc 对于对象有自动执行构造函数和析构函数
（c只能用malloc管理动态内存）
3.new返回指定类型的指针 自动计算所需要的大小；malloc必须用户指定大小，且返回类型为void*
4.new是cpp关键字，需要编译器支持。malloc是库函数，需要头文件支持。
5.new内存分配失败时会抛出异常，malloc分配失败则返回null。

***堆和栈的区别***
1.系统自动分配；需要程序猿自己申请 

2.申请后系统提供内存；系统有一个记录空闲内存地址的链表。

3.向低地址扩展，连续的内存区域；向高地址扩展，不连续的内存区域，存在碎片。

4.申请速度较快；申请速度慢，且容易产生内存碎片，不过用起来方便。




**什么是堆？什么是栈？**

**cpp内存分配中的五大区：**
1.栈区
2.堆区（动态内存分配） ：全局堆（系统没有分配的空间）局部堆（用户分配的空间）（会造成内存空间的碎片，使得效率降低）
3.静态存储区（全局静态区） 存放全局变量和静态变量 在程序编译的时候已经分配好 这块内存在程序的整个运行期间都存在
4.常量区 const
5.代码区 存放程序执行的cpu指令

**C++的内存管理**

1.代码段

2.数据段、bss段（关于全局和静态变量）

3.堆区

4.映射区

5.栈



操作系统和编译器通过内存分配的位置，判断是全局还是局部。

strcpy使用要注意什么问题？
思路：内存不能重叠

*lambda表达式、智能指针*

全局变量的生命周期==main函数生命周期==main函数中局部变量生命周期==进程的生命周期
static局部或全局变量的生命周期跟main函数相同。如果static函数先声明，则先执行

局部静态变量 和 全局变量 释放顺序：先静态 再全局 ；然后对全局变量，有先声明后释放原则

vector和list的区别：
1.vector类似于数组 （注意vector的capacity是成倍增加）list的底层就是双向链表


![](media/16152633841876.jpg)

map和set底层实现都是红黑树

set的迭代器是const（什么意思？）
map允许修改value，但不允许修改key（键）
map支持下标 ；set不支持下标 用find（找到下标）


cpp中，类定义的外部，可以被访问的成员函数或变量为public 即是可以在类外部定义具体的函数实现。
int CA::add(int a);

void* 指针：
![](media/16152835437458.jpg)

**有效指针的三种状态：**
1.保存一个特定对象的地址
2.指向某个对象后面的另一个对象
3.或者是0

**子类析构的时候要调用父类的析构函数吗？**
思路：定义一个对象时候先调用基类的构造函数，再调用派生类的构造函数；析构的时候正好相反。

***引用***

引用是一个目标变量的别名，它本身不是一种数据类型，因此不占有存储单元。
cpp函数提供了传递变量的引用。形参是引用变量时，和实参是一个变量。因此能改变实参的值。

**将引用作为函数参数的特点：**
1.相当于直接对目标对象进行操作 类似于指针
2.没有产生实参的副本 而是直接对实参进行操作（形参就是实参的副本）
3.相对于*指针变量名 的运算而言，阅读性更好 且不容易产生错误

**把引用作为函数返回值类型的格式**
好处：在内存中不产生被返回值的副本 但需要担心局部变量生命期的结束
不可以返回局部变量的引用 不能返回new分配的内存的引用

***引用和指针的区别***
1.引用必须被初始化，指针不必
2.引用初始化以后不能被改变，指针可以改变所指的对象
3.不存在指向空值的引用，但存在指向空值的指针

***const和#define***
const有数据类型，define没有数据类型。const可以进行类型安全检查，对define只有字符替换，没有安全检查。
有调试工具可以对const进行调试，而不能对define宏常量调试。

***联合和结构的区别***
对联合的不同成员赋值，其他成员的值不存在，即是重写。
联合：所有成员共用一块地址空间

**cpp是不是类型安全的？**

不是，两个不同类型的指针可以进行强制转换。

***define和typedef***
define是宏定义 预处理 的时候进行简单而机械的字符串替换，而不作正确性检查。除了定义别名 还能定义常量变量等。
typedef是关键字，在 编译 的时候处理，有类型检查功能。就是用来定义类型的别名。
它们对指针的操作不同 一个是常量指针；一个是指针常量。

***const与static的区别***
static：1.作用域，隐藏2.存储方式，值被保存，生命周期==main
const：1.只读功能 2.必须要被初始化。

*字节对齐*
**为什么要字节对齐？**
CPU访问数据的效率问题。对齐的时候，可以一次就取出数据。不然会乱。
元素按照定义顺序一个一个放到内存，但不是紧密排列。（结构体中最大类型所占字节数的最小值）

文件中的#ifndef #endif有什么用？
预处理功能（宏定义 文件包含 条件编译）中的条件编译
为了防止头文件的重复包含和编译。

getline可以忽略空格来输入 比cin多了这个功能

this指针：成员函数通过this来访问自己的地址。this指针是所有成员函数的隐含参数
this指针不能在静态函数中使用。
小故事帮助理解：this指针相当于你进了一个屋子之后，提供了一个视角，使得你还能看到他的全局。

cpp中：：冒号的作用：
表明类的作用域

强行调用父类的虚函数：直接使用：：跳过虚函数表，直接定位到父类的虚函数。

![](media/16156056251403.jpg)

堆和栈的区别：

*堆和栈的区别*
1.系统自动分配；需要程序猿自己申请 2.申请后系统提供内存；系统有一个记录空闲内存地址的链表。3.向低地址扩展，连续的内存区域；向高地址扩展，不连续的内存区域，存在碎片。4.申请速度较快；申请速度慢，且容易产生内存碎片，不过用起来方便。


![](media/16156995412885.jpg)

vector，deque，map，list，set，hashmap的实现机制。
list底层是环状双向链表。
deque是一种双开口的连续线性空间，元素在堆中。
map是基于红黑树的实现方式。优点是空间要求低，但是在查找速率上不如hashmap。
hashmap基于hashcode。查找较快，空间复杂度高。
set包含了已经排序的数据，通过红黑树实现。

*红黑树*
自平衡的二叉搜索树。根结点黑色，叶子黑色。如果节点红色，则子节点黑色。

***new和malloc的区别*：**
1.new是cpp的运算符 malloc是cpp标准函数
2.new更加智能 底层是malloc 对于对象有自动执行构造函数和析构函数
（c只能用malloc管理动态内存）
3.new返回指定类型的指针 自动计算所需要的大小；malloc必须用户指定大小，且返回类型为void*
4.new是cpp关键字，需要编译器支持。malloc是库函数，需要头文件支持。
5.new内存分配失败时会抛出异常，malloc分配失败则返回null。
*new和malloc的区别*
好像new可以重载 malloc不可以







**函数调用的底层实现**

![img](https://img-blog.csdnimg.cn/20190407202659673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lwc2hvd20=,size_16,color_FFFFFF,t_70)

从底层的汇编代码我们总结到以下三点：

1. 主调用函数的前6个参数会放到规定的6个寄存器中，被调用函数将从这6个寄存器拿数据。超过6个的部分将会放到栈中，被调用函数将从栈中取剩下的参数数据。
2. C语言的参数是从右往左准备的，也就是从右往左执行。
3. 函数内的局部变量也会放到栈中。

通常,当在一个函数的运行期间调用另一个函数时，在运行被调用函数之前，系统需要先完成3件事：
  （1）将所有的实在参数，返回地址等信息传递给被调用函数保存
  （2）为被调用函数的局部变量分配存储区
  （3）将控制转移到被调用函数的入口
  被调用函数返回调用函数之前，系统也应该完成3件工作
  （1）保存被调用函数的计算结果
  （2）释放被调函数的数据区
  （3）依照被调函数保存的返回地址将控制权转移到调用函数
————————————————

https://blog.csdn.net/ypshowm/article/details/89074450

https://blog.csdn.net/tuijiangmeng87/article/details/87900557





**判断是大端还是小端**

https://blog.csdn.net/lwfcgz/article/details/50476051

**STL的内存管理**

https://blog.csdn.net/weixin_34356310/article/details/93401844

**vector和list的区别，及其使用场景**

https://blog.csdn.net/yu876876/article/details/81698269



**socket通信总结**
https://blog.csdn.net/linghu_java/article/details/43488919

https://blog.csdn.net/qq_34272008/article/details/87454189
（包括了网络字节序和主机字节序）

![img](https://uploadfiles.nowcoder.com/images/20190315/308571_1552654678444_69CF8398BCC9F204991E623723D022E7)

分为UDP和TCP两种。

accept() send() recv()

recvfrom() sendto()



**#include<> 和 ""的区别**

一个是用于标准或者系统提供的头文件，这时候去系统保存头文件的位置去寻找。

一个是这种方式常用于程序员自己的头文件。用这种格式时，C编译器先查找当前目录是否有指定名称的头文件，然后在从标准头文件目录中查找。



**vector<vector<int>> 中>>会不会被编译器识别为右移运算符？**

C++11之前会，之后不会。



**atoi()和stoi()的相同点和区别**

https://blog.csdn.net/qq_33221533/article/details/82119031



**c++编译过程**

https://zhuanlan.zhihu.com/p/45402323

![image-20210320120908593](C:\Users\FuNgaiKa\AppData\Roaming\Typora\typora-user-images\image-20210320120908593.png)

1.编译预处理（头文件）

2.编译优化（翻译成汇编代码）.i转换成.s文件

3.汇编：将汇编语言翻译成目标机器指令。 .s文件转化成.o文件。

4.链接



**C变量类型字节数**

32位编译器：

char      short      int      long      float      double      指针

   1            2           4         4            4              8            4

64位编译器：

char      short      int      long      float      double      指针

   1            2           4         8            4              8            8


**static**

代码执行前在编译期初始化。

只能在该文件使用；不属于任何类对象，属于本类的所有对象共享，在没产生类对象之前就可以使用。

static修饰成员变量的时候，没有this指针，无法访问非静态成员。

**C++继承**

静态多态：模板、重载（编译的时候确定）

动态多态：虚函数和继承关系（动态绑定，运行的时候确定）

（1）虚函数

（2）基类指针或引用指向派生类的对象

![img](https://uploadfiles.nowcoder.com/images/20190313/311436_1552470920741_7D40CEF3951A10F626301148E06D89DA)



**判断大端小端**

![img](https://uploadfiles.nowcoder.com/images/20190313/311436_1552470995798_E694EFF3D7CC8BA2BB2EE978CE1EB6FB)





**python和C++的区别**

1.运行效率：解释执行、编译执行。

2.开发效率：代码量少



**extern和全局变量**



**I/O多路复用：select poll epoll？**

https://blog.csdn.net/wteruiycbqqvwt/article/details/90299610

https://blog.csdn.net/songchuwang1868/article/details/89877739/

https://my.oschina.net/xianggao/blog/663655



**c++编译的过程**

https://zhuanlan.zhihu.com/p/45402323





**NULL、nullptr**

有重载的时候，NULL代表（宏定义为）0（可能会选错重载的函数）；nullptr代表空指针。没有重载的时候，都是空指针。



**lambda**

使用上也是一个函数。

公式：

[capture](parameters) mutable ->return-type{statement}

lambda直接一个代码开头地址。



**extern关键字**



**内存对齐**

https://www.jianshu.com/p/c6f8bbfc0bbf

https://blog.csdn.net/weixin_40853073/article/details/81451792

该数据成员的整数倍的偏移量。
